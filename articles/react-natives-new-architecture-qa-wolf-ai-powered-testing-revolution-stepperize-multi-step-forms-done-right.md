---
title: 'React Natives New Architecture Qa Wolf Ai Powered Testing Revolution Stepperize Multi Step Forms Done Right'
excerpt: 'Przegląd 4 artykułów z ui.dev'
publishedAt: '2024-08-19'
slug: 'react-natives-new-architecture-qa-wolf-ai-powered-testing-revolution-stepperize-multi-step-forms-done-right'
hashtags: '#generated #pl #react #typescript #ai #testing'
---

## React Native's New Architecture

No dobra, ludzie, React Native w końcu doczekał się tego co powinno być od początku - kompletnego przepisania architektury. Meta w końcu przyznała, że stara architektura to było takie sobie rozwiązanie i postanowili zrobić to porządnie. 

Nowa architektura to nie jest jakiś kosmetyczny lifting, to jest kompletne przebudowanie wnętrzności React Native. Dlaczego? Bo przez lata używania w produkcji okazało się, że stara architektura miała więcej limitów niż moja cierpliwość podczas code review.

Expo już od SDK 53 w pełni wspiera nową architekturę, włącznie z bridgeless mode. Co to znaczy? Że jeśli pisałeś moduły używając Expo Modules API, to gratulacje - nie musisz nic robić, wszystko działa out of the box. A jeśli używasz bibliotek third-party, to masz narzędzie expo-doctor, które sprawdzi czy twoje dependencje są kompatybilne.

Najlepsze w tym wszystkim? Od SDK 52 wszystkie nowe projekty mają nową architekturę włączoną domyślnie. Nie ma już wymówek typu "ale to beta". To jest production ready i Meta pokazuje, że traktuje to serio.

**Kluczowe wnioski:**
- Nowa architektura rozwiązuje fundamentalne problemy starego podejścia
- Expo SDK w pełni wspiera nową architekturę od wersji 53
- Narzędzie expo-doctor pomaga sprawdzić kompatybilność bibliotek
- Nowe projekty mają nową architekturę włączoną domyślnie

https://docs.expo.dev/guides/new-architecture/

Kluczowe wnioski:
- - Nowa architektura rozwiązuje fundamentalne problemy starego podejścia
- Expo SDK w pełni wspiera nową architekturę od wersji 53
- Narzędzie expo-doctor pomaga sprawdzić kompatybilność bibliotek
- Nowe projekty mają nową architekturę włączoną domyślnie

Link: 

## QA Wolf - AI-Powered Testing Revolution

Słuchajcie, testowanie to zawsze było tym nudnym elementem developmentu, który wszyscy nienawidzą, ale muszą robić. QA Wolf postanowił to zmienić używając AI w sposób, który faktycznie ma sens.

Zamiast zmuszać developerów do separowania bugów od flaky testów, QA Wolf robi to za nas. Ich AI zaczyna investigację failed testów w ciągu sekund i przygotowuje rozwiązanie dla ludzkich QA engineerów do review. To jest właśnie to, o czym mówiłem - AI robi robotę, ludzie myślą.

Drata, jedna z najszybciej rosnących firm tech, miała problem - ich regression testing zajmował do dwóch godzin na każdy release. To jest koszmarne dla firmy, która chwali się "DrataSpeed". QA Wolf rozwiązał im ten problem, dając 86% szybsze cykle QA.

Najlepsze w tym podejściu? To nie jest kolejne no-code rozwiązanie, które obiecuje złote góry, a potem się okazuje, że nie radzi sobie z prawdziwymi, złożonymi aplikacjami. QA Wolf używa code-based framework, który radzi sobie z setkami integracji third-party i skomplikowanymi workflow.

**Kluczowe wnioski:**
- AI investiguje failed testy w sekundach, ludzie robią review
- 86% szybsze cykle QA w przypadku Drata
- Code-based framework, nie kolejne no-code rozwiązanie
- Obsługuje złożone aplikacje z setkami integracji

https://www.qawolf.com/

Kluczowe wnioski:
- - AI investiguje failed testy w sekundach, ludzie robią review
- 86% szybsze cykle QA w przypadku Drata
- Code-based framework, nie kolejne no-code rozwiązanie
- Obsługuje złożone aplikacje z setkami integracji

Link: 

## Stepperize - Multi-Step Forms Done Right

Każdy z nas robił kiedyś multi-step formy i każdy z nas wie, że to jest pain in the ass. Stepperize to biblioteka, która w końcu robi to dobrze.

Zero dependencies, tiny bundle size, TypeScript support - wszystko to, co powinno być standardem, ale rzadko jest. API jest tak proste, że można zacząć używać w ciągu minut, ale jednocześnie daje pełną kontrolę nad flow.

Najlepsze? To jest UI agnostic. Nie zmusza cię do używania ich komponentów, możesz użyć swoich. To jest właśnie to, jak powinny być robione biblioteki - dają funkcjonalność, nie dyktują wygląd.

Integruje się z dowolną biblioteką do formów albo może działać standalone. Ma persistent state, step management, form integration - wszystko co potrzebujesz, nic więcej.

**Kluczowe wnioski:**
- Zero dependencies i mały bundle size
- TypeScript support z prawdziwego zdarzenia
- UI agnostic - używasz swoich komponentów
- Proste API, ale pełna kontrola nad flow

https://stepperize.vercel.app/

Kluczowe wnioski:
- - Zero dependencies i mały bundle size
- TypeScript support z prawdziwego zdarzenia
- UI agnostic - używasz swoich komponentów
- Proste API, ale pełna kontrola nad flow

Link: 

## Prerendering with Preact Preset Vite

Preact team przez pół roku cicho rozwijał prerendering plugin w preset-vite i w końcu postanowili o tym opowiedzieć. I słusznie, bo to jest solidna robota.

Prerendering był first-class feature w Preact-CLI, potem w WMR, a teraz w Vite preset. Dlaczego? Bo Preact team wie, że prawie każda SPA zapewnia lepsze user experience gdy jest prerendered, ale większość developerów tego nie robi, bo to zbyt skomplikowane.

Ich filozofia jest prosta - im prostsze jest setup, tym więcej ludzi będzie używać prerenderingu. W Preact-CLI wystarczyło zrobić default export root componentu z JSON data. W WMR i teraz w Vite wystarczy wyeksportować prostą funkcję prerender(), która zwraca HTML dla route.

Sprawdzili ecosystem Vite przed stworzeniem własnego rozwiązania i nic im nie pasowało. Dlaczego? Bo prerendering jest najlepszy gdy jest maksymalnie drop-in. Nie chcą, żebyś przepisywał pół aplikacji, żeby dodać prerendering.

**Kluczowe wnioski:**
- Prerendering był zawsze priorytetem w toolingu Preact
- Filozofia: im prostszy setup, tym więcej adopcji
- Drop-in rozwiązanie - minimalne zmiany w kodzie
- Własna implementacja bo ecosystem Vite nie miał odpowiedniego rozwiązania

https://preactjs.com/blog/prerendering-preset-vite/

Kluczowe wnioski:
- - Prerendering był zawsze priorytetem w toolingu Preact
- Filozofia: im prostszy setup, tym więcej adopcji
- Drop-in rozwiązanie - minimalne zmiany w kodzie
- Własna implementacja bo ecosystem Vite nie miał odpowiedniego rozwiązania

Link: