---
title: 'Progressive Json Overreacted Announcing Vitest 32 Cve 2025 48757'
excerpt: 'Przegląd 4 artykułów z ui.dev'
publishedAt: '2025-10-26'
slug: 'progressive-json-overreacted-announcing-vitest-32-cve-2025-48757'
hashtags: '#generated #pl #react #typescript #pnpm #ai #css'
---

## Progressive JSON — overreacted

No to mamy tutaj absolutnie genialne podejście od Dana Abramova do problemu, który wszyscy znamy, ale nikt się nad nim nie zastanawia. Wiecie co to Progressive JPEG? Zamiast ładować obrazek linijka po linijce od góry do dołu, obrazek jest najpierw rozmazany i stopniowo staje się ostrzejszy. Dan pyta - a co jeśli zastosujemy to samo do JSONa?

Problem jest prosty - kiedy wysyłamy JSON przez sieć, klient nie może zrobić nic z danymi dopóki nie dostanie ostatniego bajtu. Musi czekać na całość, potem wywołać JSON.parse i dopiero wtedy może coś z tym zrobić. To znaczy, że jeśli część danych jest wolno generowana na serwerze - powiedzmy komentarze z wolnej bazy danych - klient musi czekać na wszystko zanim zacznie jakąkolwiek pracę.

Dan proponuje streaming JSON parser, ale zauważa, że naiwne podejście też nie jest idealne, bo obiekty są niepełne i nie wiadomo co jest gotowe a co nie. Tutaj wchodzi koncepcja Progressive JSON - podobnie jak Progressive JPEG pokazuje rozmyty ale kompletny obraz, Progressive JSON powinien dać nam użyteczną strukturę danych nawet gdy nie wszystko jeszcze dotarło.

**Key takeaways:**
- Tradycyjny JSON blokuje renderowanie do momentu otrzymania ostatniego bajtu
- Streaming JSON ma problemy z niepełnymi obiektami
- Progressive JSON może być odpowiedzią na te problemy
- Koncepcja inspirowana Progressive JPEG

**Link:** [link](https://overreacted.io/progressive-json/)

## Announcing Vitest 3.2

Vitest 3.2 wyszedł i skupia się głównie na Browser Mode i lepszym wsparciu TypeScript. Największą zmianą jest deprecation workspace config na rzecz projects - zespół chce uprościć konfigurację i unikać konfliktów z innymi narzędziami jak PNPM.

Nowe API do adnotacji pozwala dodawać custom wiadomości i załączniki do testów - widoczne w UI, HTML i innych reporterach. To może być bardzo przydatne do debugowania.

Fixtures teraz mogą mieć scope - file lub worker. File fixture to jak beforeAll i afterAll na poziomie pliku, ale tylko jeśli fixture jest używane. Worker fixture jest inicjowane raz na worker - ale pamiętajcie, że domyślnie Vitest tworzy jeden worker na test, więc musicie wyłączyć izolację żeby z tego skorzystać.

Możecie teraz ustawiać custom kolory dla projektów w konfiguracji - drobnostka ale miła. Plus nowe API do custom browser locators - zamiast spadać do CSS i tracić retry-ability, możecie rozszerzyć locators używając locators.extend.

**Key takeaways:**
- Workspace config jest deprecated na rzecz projects
- Nowe API do adnotacji testów
- Scoped fixtures z opcjami file i worker
- Custom kolory projektów
- Rozszerzalne browser locators

**Link:** [link](https://vitest.dev/blog/vitest-3-2.html)

## CVE-2025-48757

To jest naprawdę poważna sprawa. Lovable - platforma do generowania projektów - ma fundamentalny problem z Row Level Security w Postgres. Projekty generowane przez Lovable mogą być wdrażane z niewystarczającymi politykami RLS, co może prowadzić do wycieku wrażliwych danych.

Problem polega na tym, że Lovable tworzy frontend aplikacje które robią bezpośrednie REST API calle do bazy danych z klienta, używając publicznego anon key i polegając wyłącznie na RLS dla bezpieczeństwa. Jeśli tabela ma brakujące lub niewystarczające polityki RLS, atakujący może modyfikować REST requesty żeby dostać się do danych których nie powinien widzieć.

CVSS score to 8.26 base i 7.58 temporal - to jest high severity. Dotyczy wszystkich wersji Lovable i jak na razie nie ma fix'a. Atakujący może nie tylko czytać dane ale też wstrzykiwać, aktualizować lub usuwać dane.

To pokazuje jak ważne jest właściwe skonfigurowanie RLS w Postgres i dlaczego nie można polegać tylko na frontend'owych zabezpieczeniach.

**Key takeaways:**
- Wszystkie wersje Lovable są podatne
- Problem z niewystarczającymi politykami RLS w Postgres
- Możliwy wyciek PII i innych wrażliwych danych
- Brak fix'a w momencie publikacji
- CVSS 8.26 - high severity

**Link:** [link](https://mattpalmer.io/posts/CVE-2025-48757/)

## Root Shell on Credit Card Terminal

Stefan Gloor wziął na warsztat terminal płatniczy Worldline Yomani XR - ten sam model który jest wszędzie w Szwajcarii. Spodziewał się mocno zahardowanego urządzenia z tonami zabezpieczeń i w pewnym stopniu miał rację.

Terminal ma naprawdę przemyślane zabezpieczenia tamper - zamiast prostego switcha, używają board-to-board interconnects z Zebra strips które są wrażliwe na nacisk. Nawet odkręcenie niektórych śrub wystarcza żeby wywołać tamper event. Plus mają zig-zag traces na PCB które działają jak tamper detection - jedno przypadkowe przerwanie ścieżki i koniec zabawy.

Po otwarciu urządzenia dostał wielki czerwony ekran "TAMPER DETECTED" i terminal stał się kompletnie nieresponsywny. Więc przeszedł do chip-off firmware extraction - fizycznie zdjął flash chip i przeczytał firmware.

Analiza firmware'u pokazała custom ASIC "Samoa II", dual-core ARM processor. Udało mu się znaleźć sposób na uzyskanie root shell poprzez eksploitację bootloader'a i chain'owanie exploitów.

To pokazuje że nawet urządzenia z wysokimi zabezpieczeniami mogą mieć luki, ale wymagają naprawdę zaawansowanych technik i fizycznego dostępu.

**Key takeaways:**
- Zaawansowane zabezpieczenia tamper w terminalach płatniczych
- Chip-off extraction jako metoda analizy firmware
- Custom ASIC "Samoa II" z ARM cores
- Możliwe uzyskanie root shell przez bootloader exploits
- Wymaga fizycznego dostępu i zaawansowanych umiejętności

**Link:** [link](https://stefan-gloor.ch/yomani-hack)